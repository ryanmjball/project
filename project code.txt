import ultralytics
!pip install graphics.py
from graphics import Point
from ultralytics import YOLO
import pandas as pd
import cv2
import numpy as np
import math
import sys
print(sys.version)
class Tracker:
    def _init_(self):
        # Store the center positions of the objects
        self.center_points = {}
        # Keep the count of the IDs
        # each time a new object id detected, the count will increase by one
        self.id_count = 0


    def update(self, objects_rect):
        # Objects boxes and ids
        objects_bbs_ids = []

        # Get center point of new object
        for rect in objects_rect:
            x, y, w, h = rect
            cx = (x + x + w) // 2
            cy = (y + y + h) // 2

            # Find out if that object was detected already
            same_object_detected = False
            for id, pt in self.center_points.items():
                dist = math.hypot(cx - pt[0], cy - pt[1])

                if dist < 35:
                    self.center_points[id] = (cx, cy)
#                    print(self.center_points)
                    objects_bbs_ids.append([x, y, w, h, id])
                    same_object_detected = True
                    break

            # New object is detected we assign the ID to that object
            if same_object_detected is False:
                self.center_points[self.id_count] = (cx, cy)
                objects_bbs_ids.append([x, y, w, h, self.id_count])
                self.id_count += 1

        # Clean the dictionary by center points to remove IDS not used anymore
        new_center_points = {}
        for obj_bb_id in objects_bbs_ids:
            _, _, _, _, object_id = obj_bb_id
            center = self.center_points[object_id]
            new_center_points[object_id] = center

        # Update dictionary with IDs not used removed
        self.center_points = new_center_points.copy()
        return objects_bbs_ids

class Point:
    def _init_(self, x, y):
        self.x = x
        self.y = y

class Point:
    def _init_(self, x, y):
        self.x = x
        self.y = y   
import time
import cv2
model=YOLO('yolov8s.pt')
tracker=Tracker()
class_list = ['person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush']
cap=cv2.VideoCapture(r"D:\20240715_135005.mp4")
down={}
up={}

counter_down=[]
counter_up=[]
def point_in_polygon(point,rect):
            num_vertices = len(rect)
            x, y = point.x, point.y
            print(x)
            print(y)
            inside = False
 
    # Store the first point in the polygon and initialize the second point
            p1 = rect[0]
 
    # Loop through each edge in the polygon
            for i in range(1, num_vertices + 1):
        # Get the next point in the polygon
              p2 = rect[i % num_vertices]
 
        # Check if the point is above the minimum y coordinate of the edge
              if y > min(p1.y, p2.y):
            # Check if the point is below the maximum y coordinate of the edge\
                  
                 if y <= max(p1.y, p2.y):
                # Check if the point is to the left of the maximum x coordinate of the edge
                    if x <= max(p1.x, p2.x):
                    # Calculate the x-intersection of the line connecting the point to the edge
                       x_intersection = (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x
 
                    # Check if the point is on the same line as the edge or to the left of the x-intersection
                       if p1.x == p2.x or x <= x_intersection:
                        # Flip the inside flag
                         inside = not inside
 
        # Store the current point as the first point for the next iteration
              p1 = p2
 
    # Return the value of the inside flag
              return inside
class Point:
    def _init_(self, x, y):
        self.x = x
        self.y = y
def lineLineIntersection(A, B, C, D):
    # Line AB represented as a1x + b1y = c1
    a1 = B.y - A.y
    b1 = A.x - B.x
    c1 = a1*(A.x) + b1*(A.y)
 
    # Line CD represented as a2x + b2y = c2
    a2 = D.y - C.y
    b2 = C.x - D.x
    c2 = a2*(C.x) + b2*(C.y)
 
    determinant = a1*b2 - a2*b1
 
    if (determinant == 0):
        # The lines are parallel. This is simplified
        # by returning a pair of FLT_MAX
        return Point(10*9, 10*9)
    else:
        x = (b2*c1 - b1*c2)/determinant
        y = (a1*c2 - a2*c1)/determinant
        return Point(x, y)
ptime=0
while True:  
    count=0
    ret,frame = cap.read()
    frame=frame[:,:]
    if not ret:
        break
    count += 1
   

    results=model.predict(frame)
 #   print(results)
    a=results[0].boxes.data
    a = a.detach().cpu().numpy()  # added this line
    px=pd.DataFrame(a).astype("float")
    #print(px)

    list=[]
    pts = np.array([[900,380], 
                [1500, 620], [250, 620], 
                [800, 380]],
               np.int32) 
    pts = pts.reshape((-1, 1, 2))
    isClosed = True
    color = (255, 0, 0)
    thickness = 2
    gray1= cv2.polylines(frame, [pts], 
                      isClosed, color, thickness)#lines that boders the detection area
    #a=Point(370, 170)
    #b=Point(700, 280)
    #cv2.line(frame,a,b,(0,255,0),2)
    #cv2.line(frame,(450, 170),(700, 280),(0,255,0),2)
    #dist=math.sqrt((math.pow((700-450),2))+(math.pow((280-170),2)))
    #print(dist)
    for index,row in px.iterrows():
#        print(row) 
        x1=int(row[0])
        y1=int(row[1])
        x2=int(row[2])
        y2=int(row[3])
        d=int(row[5])
        c=class_list[d]
        
        if 'car' in c or 'truck' in c or 'cow' in c:
            list.append([x1,y1,x2,y2])
            #print(c)

            bbox_id=tracker.update(list)
            #print(bbox_id)
            for bbox in bbox_id:
             x3,y3,x4,y4,id=bbox
             cx=int(x3+x4)//2
             cy=int(y3+y4)//2
             c=Point(0,y4)
             d=Point(1300,y4)
             #c=Point(0,170)
             #d=Point(600,170)
             #cv2.line(frame,c,d,(0,255,0),2)
             point1=Point(x3,y3)
             point2=Point(x4,y3)
             point3=Point(x3,y4)
             point4=Point(x4,y4)
             midpoint1=Point(x3,cy)
             midpoint2=Point(x4,cy)
             midpoint3=Point(cx,y3)
             midpoint4=Point(cx,y4)
             #dist=math.sqrt(math.pow((cx-600),2)+math.pow((cy-640),2))
             #dist=str(dist)
             #if (x3>130 and x3<1030) or (x4>130 and x4<1030):
                    # if (y3>390 and y3<640) or (y4>390 and y4<640):
                         #cv2.rectangle(frame,(x3,y3),(x4,y4),(0,0,255),2)
             nowcx=cx
             nowcy=cy
             cv2.circle(frame,(x3,cy),4,(0,0,255),-1)
             cv2.circle(frame,(x4,cy),4,(0,0,255),-1)
             cv2.circle(frame,(cx,y3),4,(0,0,255),-1)
             cv2.circle(frame,(cx,y4),4,(0,0,255),-1)
             a=Point(900,380)
             b=Point(1500, 620)
             #cv2.line(frame,a,b,(0,255,0),2)
             cv2.line(frame,(900,380),(1500, 620),(0,255,0),2)
             a1=Point(1030,640)
             b1=Point(640,390)
            
             if cx>800 and cx<900 and y3>170 and y3<280:
                cv2.rectangle(frame,(x3,y3),(x4,y4),(255,0,0),2)
                #cv2.line(frame,c,d,(0,255,0),2)
                
                intersection = lineLineIntersection(a, b, c, d)
                x=intersection.x
                y=intersection.y
                cv2.circle(frame,(int(x),int(y)),4,(0,0,255),-1)
                #intersection2 = lineLineIntersection(a1, b1, c, d)
                #x1=intersection2[0]
                #y1=intersection2[1]
                dist=math.sqrt((math.pow((x-1500),2))+(math.pow((y-620),2)))
                dist=dist*.037
                #dist1=math.sqrt((math.pow((x1-130),2))+(math.pow((y1-640),2)))
                #distavg=(dist1+dist)/2
                cv2.putText(frame,str(dist),(x3,y4), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                timee=dist/9.7
                print(timee)
                #cv2.putText(frame,str(timee),(x3,y3), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                if timee<0.7:
                 cv2.putText(frame,"please break",(440,440), cv2.FONT_HERSHEY_SIMPLEX, 4,(0,0,255) , cv2.LINE_4)
                 print("break")
                else:
                 pass
                 
             elif cx>250 and cx<1500 and y4>380 and y4<620:
                cv2.rectangle(frame,(x3,y3),(x4,y4),(255,0,0),2)
                #cv2.line(frame,c,d,(0,255,0),2)
               
                intersection = lineLineIntersection(a, b, c, d)
                x=intersection.x
                y=intersection.y
                cv2.circle(frame,(int(x),int(y)),4,(0,0,255),-1) 
                #intersection2 = lineLineIntersection(a1, b1, c, d)
                #x1=intersection2[0]
                #y1=intersection2[1]
                dist=math.sqrt((math.pow((x-1500),2))+(math.pow((y-620),2)))
                dist=dist*.037
                #dist1=math.sqrt((math.pow((x1-130),2))+(math.pow((y1-640),2)))
                #distavg=(dist1+dist)/2
                cv2.putText(frame,str(dist),(x3,y4), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                timee=dist/9.7
                print(timee)
                #cv2.putText(frame,str(timee),(x3,y3), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                if timee<0.7:
                 cv2.putText(frame,"please break",(440,440), cv2.FONT_HERSHEY_SIMPLEX, 4,(0,0,255) , cv2.LINE_4)
                 print("break")
                else:
                 pass
            
             elif x3>800 and x3<900 and cy>380 and cy<620:
                cv2.rectangle(frame,(x3,y3),(x4,y4),(255,0,0),2)
                #cv2.line(frame,c,d,(0,255,0),2)
                
                intersection = lineLineIntersection(a, b, c, d)
                x=intersection.x
                y=intersection.y
                cv2.circle(frame,(int(x),int(y)),4,(0,0,255),-1)
                #intersection2 = lineLineIntersection(a1, b1, c, d)
                #x1=intersection2[0]
                #y1=intersection2[1]
                dist=math.sqrt((math.pow((x-1500),2))+(math.pow((y-620),2)))
                dist=dist*.037
                #dist1=math.sqrt((math.pow((x1-130),2))+(math.pow((y1-640),2)))
                #distavg=(dist1+dist)/2
                cv2.putText(frame,str(dist),(x3,y4), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                timee=dist/9.7
                print(timee)
                #cv2.putText(frame,str(timee),(x3,y3), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                if timee<0.7:
                 cv2.putText(frame,"please break",(440,440), cv2.FONT_HERSHEY_SIMPLEX, 4,(0,0,255) , cv2.LINE_4)
                 print("break")
                else:
                 pass
                
             elif x4>250 and x4<1500 and cy>380 and cy<620:
                cv2.rectangle(frame,(x3,y3),(x4,y4),(255,0,0),2)
                #cv2.line(frame,c,d,(0,255,0),2)
                intersection = lineLineIntersection(a, b, c, d)
                x=intersection.x
                y=intersection.y
                cv2.circle(frame,(int(x),int(y)),4,(0,0,255),-1)
                #intersection2 = lineLineIntersection(a1, b1, c, d)
                #x1=intersection2[0]
                #y1=intersection2[1]
                #ctime=cap.get(cv2.CAP_PROP_POS_MSEC) / 1000.0 # Get current time in second
                dist=math.sqrt((math.pow((x-1500),2))+(math.pow((y-620),2)))
                dist=dist*.037
                #dist1=math.sqrt((math.pow((x1-130),2))+(math.pow((y1-640),2)))
                #distavg=(dist1+dist)/2
                cv2.putText(frame,str(dist),(x3,y4), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                timee=dist/9.7
                print(timee)
                #cv2.putText(frame,str(timee),(x3,y3), cv2.FONT_HERSHEY_SIMPLEX, 1,(0, 255, 0) , cv2.LINE_4)
                if timee<0.7:
                 cv2.putText(frame,"please break",(440,440), cv2.FONT_HERSHEY_SIMPLEX, 4,(0,0,255) , cv2.LINE_4)
                 
                 print("break")
                else:
                 pass
            
             else: 
              pass
            
                        
                 #cv2.rectangle(frame,(x3,y3),(x4,y4),(0,0,255),2)
    cv2.imshow("frames", frame)
    if cv2.waitKey(1)&0xFF==ord('g'):
      break
cap.release()
cv2.destroyAllWindows()
